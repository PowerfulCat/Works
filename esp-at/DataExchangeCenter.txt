
struct Any{
    Any(String str) : 
        str(& tmpStr), 
        tmpStr(str){
    }
    Any(int32_t v) : 
        i32(& tmpI32), 
        tmpI32(v){
    }
    Any(Ipv4 v) : 
        ip(& tmpIp), 
        tmpIp(v){
    }
    Any(Mac v) : 
        ip(& tmpMac),
        tmpMac(v){
    }
    Any(DateTime v) : 
        time(& tmpTime), 
        tmpTime(v){
    }
    Any(bool v) : 
        i32(& tmpI32), 
        tmpI32(v){
    }
    
    Any(int32_t * v) : 
        i32(v){
    }
    Any(Ipv4 * v) : 
        ip(v){
    }
    Any(Mac * v) : 
        ip(v){
    }
    Any(DateTime * v) : 
        time(v){
    }
    Any(bool * v) : 
        i8((int8_t)v){
    }
    union{
        String  *   str;
        int32_t *   i32;
        int8_t  *   i8;
        Ipv4    *   ip;
        Mac     *   mac;
        DateTime*   time;
    };
private:
    String          tmpStr; // put to union will result memory leak.
    union{
        int32_t     tmpI32;
        Ipv4        tmpIp;
        Mac         tmpMac;
        DateTime    tmpTime;
    };
};

#define T_US            1000000.0
#define T_MS            1000.0
#define ESP_BYTE_RATE   (115200.0 / 11)
#define MAX_DESIRED     50.0
#define COST_US(bytes)  uint32_t(T_US / ESP_BIT_RATE * (bytes))
#define RT_SLEEP_US(us) 
#define ei

struct Ipd{
    int32_t     length;
    int32_t     port;
    Ipv4        ip;
    uint8_t *   data;
    void release(){
        delete [] data;
    }
};

int itrRxPin;

void detectRxFalling(){
    detachInterrupt(itrRxPin);
    esp.signal.pushRequest();
}

// default:
// - wifi multi-connection
// - close echo
// - show IPD remote ip:port

void dataExchangeCenter(){
    while(true){
        esp.signal.wait();
        esp.signal.handleOne();
        passive = passiveRx;
        passiveRx = false;

        if (cmd.que.size()){
            writeLine(cmd.que.front());
            cmd.que.pop();
        }

        resp = readUntil(':', '\n');

        // async signal
        // system reset
        if (resp.startsWith("ready")){
            resetFlag();
            whenReset();
        }
        ei (resp.startsWith("WIFI CONNECTED")){
            wifi.state = WifiConnected;
            wifi.whenWifiStateChange();
        }
        ei (resp.startsWith("WIFI GOT IP")){
            wifi.state = WifiGotIp;
            wifi.whenWifiStateChange();
        }
        ei (resp.startsWith("WIFI DISCONNECT")){
            wifi.state = WifiDisconnect;
            wifi.whenWifiStateChange();
        }
        ei (resp.startsWith("smartconfig connected wifi")){
            smart.isFail = 1;
            smart.isSuccess = 0;
            smart.whenRising();
        }
        ei (resp.startsWith("smartconfig connect fail")){
            smart.isFail = 0;
            smart.isSuccess = 1;
            smart.whenRising();
        }
        ei (resp.startsWith("+IPD")) {
            int32_t id;
            Ipd     ipd;
            sscanf(resp.c_str(), "+IPD,%d,%d,%d.%d.%d.%d,%d", 
                & id, 
                & ipd.length, 
                & ipd.ip[0], 
                & ipd.ip[1], 
                & ipd.ip[2], 
                & ipd.ip[3],
                & ipd.port
            );
            ipd.data = new uint8_t[ipd.length];

            for (int32_t i = 0; i < ipd.length; i++){
                if (available()){
                    ipd.data[i] = read();
                }
                else{
                    RT_SLEEP_US(COST_US(ipd.length - i));
                }
            }
            wifi.packet[id].push(ipd);
            wifi.whenRxPacket();
        }

        // rx invoke
        if (analysis.que.size()){
            auto && rqt = analysis.que.front();
            rqt.invoke(resp, rqt.args);
        }
    }
}

void rxMain(String & resp, Any * buf){
    for(char * str = resp.c_str(); buf->isEmpty() == false; buf += 1, str += 1){ // skip ,
        switch(buf->type){
        case TypeI08: 
            parseInt(& str, 'd', & buf->i08); 
            break;
        case TypeI32: 
            parseInt(& str, 'd', & buf->i32); 
            break;
        case TypeX32: 
            parseInt(& str, 'x', & buf->i32); 
            break;
        case TypeStr: 
            parseStr(& str, & buf->str);
            break;
        case TypeIp:
            parseNetCode(& str, 'd', & buf->ip);
            break;
        case TypeMac:
            parseNetCode(& str, 'x', & buf->mac);
            break;
        case TypeTime:
            parseTime(& str, 'd', & buf->time);
            break;
        default: debug("ERROR TYPE %d in parse.\n", buf->type); break;
        }
    }
}

void txMain(String * resp, Any * buf){
    char buf[32];
    resp[0] = "";
    while(true){
        switch(buf->type){
        case TypeI08: 
        case TypeI32: 
            itoa(buf, 10, buf->i32[0]);
            resp[0] += buf;
            break;
        case TypeStr: 
            resp[0] += '\"';
            resp[0] += str[0];
            resp[0] += '\"';
            break;
        case TypeIp:
            parseNetCode(& str, 'd', buf->ip[0]);
            break;
        case TypeMac:
            parseNetCode(& str, 'x', buf->mac[0]);
            break;
        case TypeTime:
            parseTime(& str, 'd', buf->time[0]);
            break;
        default: debug("ERROR TYPE %d in parse.\n", buf->type); break;
        }
        buf += 1;

        if (buf->isEmpty() == false){
            resp[0] += ",";
        }
    }
    resp[0] += END_LINE;
}

template<class ... args>
void rx(const char * token, args ... list){
    esp.analysis.que.push({
        [](String & resp, Any * buf){
            if (resp.startsWith(token) == false){
                return;
            }
            rxMain(readUntil('\n'), buf);
        }, list..., nullptr // nullptr as end of args
    });
}

template<class ... args>
void tx(const char * token, args const & ... list){
    String cmd = token;
    Any args[] = { list..., nullptr }; // nullptr as end of args
    rxMain(& cmd, args);
    esp.cmd.que.push(cmd);
    esp.signal.pushRequest();
}


